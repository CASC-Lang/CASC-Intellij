{
  parserClass="org.casc.lang.parser.CASCParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CASC"
  psiImplClassSuffix="Impl"
  psiPackage="org.casc.lang.psi"
  psiImplPackage="org.casc.lang.psi.impl"

  elementTypeHolderClass="org.casc.lang.psi.CASCTypes"
  elementTypeClass="org.casc.lang.psi.CASCElementType"
  tokenTypeClass="org.casc.lang.psi.CASCTokenType"

  tokens = [
    COMMENT = 'regexp://.*'
  ]
}

cascFile                ::= packageDeclaration? usage* classDeclaration? implementation*

accessModifiers         ::= PUB | PROT | INTL | PRIV

mutableModifier         ::= MUT

type                    ::= (IDENTIFIER (DOUBLE_COLON IDENTIFIER)*)
complexType             ::= type (OPEN_BRACKET CLOSE_BRACKET)*

packageDeclaration      ::= PACKAGE type

usage                   ::= USE type (AS IDENTIFIER) | (DOUBLE_COLON OPEN_BRACE usage (COMMA usage)+ CLOSE_BRACE)

classDeclaration        ::= accessModifiers? mutableModifier? CLASS IDENTIFIER (OPEN_BRACE classFields* CLOSE_BRACE)?

classFields             ::= (COMP OPEN_BRACE classFields CLOSE_BRACE) | (accessModifiers? mutableModifier? COLON field+)

field                   ::= IDENTIFIER COLON complexType

implementation          ::= IMPL IDENTIFIER (COLON type)? (OPEN_BRACE companionBlock? (functionDeclaration | constructorDeclaration)* CLOSE_BRACE)?

companionBlock          ::= COMP OPEN_BRACE statement* CLOSE_BRACE

functionDeclaration     ::= FN IDENTIFIER OPEN_PARENTHESES (SELF COMMA)? parameterList CLOSE_PARENTHESES (COLON complexType)? OPEN_BRACE statement* CLOSE_BRACE

constructorDeclaration  ::= NEW OPEN_PARENTHESES parameterList CLOSE_PARENTHESES (COLON (SELF | SUPER) OPEN_PARENTHESES parameterList CLOSE_PARENTHESES)? OPEN_BRACE statement* CLOSE_BRACE

parameterList           ::= IDENTIFIER COLON complexType (COMMA IDENTIFIER COLON complexType)*

statement               ::= variableDeclaration | expression

variableDeclaration     ::= IDENTIFIER COLON_EQUAL expression

expression              ::= literalExpression
                        | arrayInitialization
                        | arrayDeclaration
                        | constructorCall
                        | memberExpression

memberExpression        ::= (functionCall | IDENTIFIER) (DOT memberExpression)?

constructorCall         ::= NEW type OPEN_PARENTHESES argumentList CLOSE_PARENTHESES

functionCall            ::= IDENTIFIER OPEN_PARENTHESES argumentList CLOSE_PARENTHESES

argumentList            ::= (expression (COMMA expression)*)?

literalExpression       ::= NULL
                        | TRUE
                        | FALSE
                        | (DOUBLE_QUOTE (STRING_CHAR | ESCAPED_STRING_CHAR)* DOUBLE_QUOTE)
                        | (QUOTE (STRING_CHAR | ESCAPED_STRING_CHAR)* QUOTE)
                        | INTEGER_LITERAL
                        | FLOAT_LITERAL

arrayInitialization     ::= ((type COLON (OPEN_BRACKET CLOSE_BRACKET)+) | COLON) OPEN_BRACE argumentList CLOSE_BRACE

arrayDeclaration        ::= type COLON (OPEN_BRACKET expression CLOSE_BRACKET)+ OPEN_BRACE CLOSE_BRACE
